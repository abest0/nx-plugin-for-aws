import { Logger } from '@aws-lambda-powertools/logger';
import { Metrics, MetricUnit } from '@aws-lambda-powertools/metrics';
import { Tracer } from '@aws-lambda-powertools/tracer';
import { initTRPC, TRPCError } from '@trpc/server';
import { Context as APIGWContext } from 'aws-lambda';
import { Subsegment } from 'aws-xray-sdk-core';

export type IMiddlewareContext = ILoggerContext &
  IMetricsContext &
  ITracerContext;

interface ILoggerContext extends APIGWContext {
  logger: Logger;
}

interface IMetricsContext extends APIGWContext {
  metrics: Metrics;
}

interface ITracerContext extends APIGWContext {
  tracer: Tracer;
}

export const createLoggerPlugin = () => {
  const t = initTRPC.context<ILoggerContext>().create();
  return {
    loggerPlugin: t.procedure.use(async (opts) => {
      const logger = new Logger();

      const response = await opts.next({
        ctx: {
          ...opts.ctx,
          logger,
        },
      });

      if (!response.ok) {
        logger.error('Unexpected error occured', response.error.cause ?? '');
      }

      return response;
    }),
  };
};

export const createMetricsPlugin = () => {
  const t = initTRPC.context<IMetricsContext>().create();

  return {
    metricsPlugin: t.procedure.use(async (opts) => {
      const metrics = new Metrics();
      metrics.captureColdStartMetric();

      metrics.addMetric('requestCount', MetricUnit.Count, 1);

      try {
        const response = await opts.next({
          ctx: {
            ...opts.ctx,
            metrics,
          },
        });

        if (!response.ok) {
          metrics.addMetric('errorCount', MetricUnit.Count, 1);
        } else {
          metrics.addMetric('successCount', MetricUnit.Count, 1);
        }

        return response;
      } finally {
        metrics.publishStoredMetrics();
      }
    }),
  };
};

export const createTracerPlugin = () => {
  const t = initTRPC.context<ITracerContext>().create();

  return {
    tracerPlugin: t.procedure.use(async (opts) => {
      const tracer = new Tracer();
      const segment = tracer.getSegment();
      let handlerSegment: Subsegment | undefined;

      if (segment) {
        handlerSegment = segment.addNewSubsegment(`## ${opts.path}`);
        tracer.setSegment(handlerSegment);
      }

      tracer.annotateColdStart();
      tracer.addServiceNameAnnotation();

      try {
        const response = await opts.next({
          ctx: {
            ...opts.ctx,
            tracer,
          },
        });

        if (!response.ok && response.error.cause instanceof Error) {
          tracer.addErrorAsMetadata(response.error.cause);
        }
        return response;
      } finally {
        if (segment && handlerSegment) {
          handlerSegment.close();
          tracer.setSegment(segment);
        }
      }
    }),
  };
};

export const createErrorPlugin = () => {
  const t = initTRPC.context().create();
  return {
    errorPlugin: t.procedure.use(async (opts) => {
      const response = await opts.next({
        ctx: {
          ...opts.ctx,
        },
      });

      if (!response.ok) {
        let trpcError: TRPCError;

        if (response.error.cause instanceof TRPCError) {
          trpcError = response.error.cause;
        } else {
          trpcError = new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'An unexpected error occurred, please try again later.',
            cause: response.error.cause,
          });
        }

        throw trpcError;
      } else {
        return response;
      }
    }),
  };
};
